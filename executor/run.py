#!/usr/bin/env python3

import json
import os
import pathlib
import random
import shutil
import subprocess
import sys
import telnetlib
import tempfile
import threading
import time


# Range of ports where QMP could be bound.
QMP_PORT_RANGE = (50000, 55000)

# How many seconds to wait after a graceful shutdown signal before killing the
# virtual machine.
GRACEFUL_SHUTDOWN_TIMEOUT = 60


class VM:
    def __init__(self, instance, env):
        self._base = instance["image"]
        self._vm_timeout = instance["timeout-seconds"]
        self._ssh_port = instance["ssh-port"]
        self._cpu = instance["cpu-cores"]
        self._ram = instance["ram"]
        self._disk = instance["root-disk"]
        self._env = env

        self._path = pathlib.Path(tempfile.mkdtemp())
        self._path_root = self._path / "root.qcow2"
        self._path_cdrom = self._path / "env.iso"

        self._process = None
        self._qmp_shutdown_port = random.randint(*QMP_PORT_RANGE)
        self._qmp_tray_ejector_port = random.randint(*QMP_PORT_RANGE)

        self._copy_base_image()
        self._create_config_cdrom()

    def _copy_base_image(self):
        if self._path.exists():
            shutil.rmtree(self._path)

        self._path.mkdir(exist_ok=True)

        print("==> creating the disk image")
        subprocess.run([
            "qemu-img", "create",
            # Path of the base image.
            "-b", str(pathlib.Path(self._base).resolve()),
            # Use a Copy on Write filesystem, to avoid having to copy the whole
            # base image every time we start a VM.
            "-f", "qcow2",
            # Path of the destination image.
            str(self._path_root.resolve()),
            # New size of the disk.
            self._disk,
        ], check=True)

    def _create_config_cdrom(self):
        tempdir = pathlib.Path(tempfile.mkdtemp())
        envjson = tempdir / "instance.json"

        with envjson.open("w") as f:
            json.dump(self._env, f)

        print("==> creating the virtual CD-ROM with the instance configuration")
        subprocess.run([
            "genisoimage",
            "-output", str(self._path_cdrom.resolve()),
            "-input-charset", "utf-8",
            # Call the ISO "instance-configuration"
            "-volid", "instance-configuration",
            # Generate a Joliet filesystem, which is preferred by Windows.
            "-joliet",
            # Generate a Rock Ridge filesystem, which is preferred by Linux.
            "-rock",
            # Include the `instance.json` file in the ISO.
            str(envjson.resolve()),
        ], check=True)

        shutil.rmtree(str(tempdir))

    def run(self):
        if self._process is not None:
            raise RuntimeError("this VM was already started")

        def preexec_fn():
            # Don't forward signals to QEMU
            os.setpgrp()

        print("==> starting the virtual machine")
        self._process = subprocess.Popen([
            "qemu-system-x86_64",
            # Enable hardware acceleration.
            "-enable-kvm",
            # Reserved RAM for the virtual machine.
            "-m", str(self._ram),
            # Allocated cores for the virtual machine.
            "-smp", str(self._cpu),
            # Prevent QEMU from showing a graphical console window.
            "-display", "none",
            # Mount the VM image as the root drive.
            "-drive", "file=" + str(self._path_root) + ",media=disk,if=virtio",
            # Enable networking inside the VM.
            "-net", "nic,model=virtio",
            # Forward the 22 port on the host, as the configured SSH port.
            "-net", "user,hostfwd=tcp::" + str(self._ssh_port) + "-:22",
            # Mount the instance configuration as a CD-ROM. The mounted ISO is
            # generated by the _create_config_cdrom method.
            "-cdrom", str(self._path_cdrom),
            # This QMP port is used by the shutdown() method to send the
            # shutdown signal to the QEMU VM instead of killing it.
            "-qmp", "telnet:127.0.0.1:" + str(self._qmp_shutdown_port) + ",server,nowait",
            # This QMP port is used by the TrayEjector thread to eject the
            # CD-ROM as soon as the guest VM opens the tray.
            "-qmp", "telnet:127.0.0.1:" + str(self._qmp_tray_ejector_port) + ",server,nowait",
        ], preexec_fn=preexec_fn)

        TrayEjectorThread(self._qmp_tray_ejector_port).start()
        Timer("vm-timeout", self.shutdown, self._vm_timeout).start()

        try:
            self._process.wait()
        except KeyboardInterrupt:
            self.shutdown()

        # Shutdown signal was successful, wait for clean shutdown
        try:
            if self._process is not None:
                self._process.wait()
        except KeyboardInterrupt:
            self.kill()

    def shutdown(self):
        if self._process is None:
            raise RuntimeError("can't shutdown a stopped VM")

        # QEMU allows interacting with the VM through the "monitoring port",
        # using Telnet as the protocol. This tries to connect to the monitoring
        # port to send the graceful shutdown signal. If it fails, we're forced
        # to hard-kill the virtual machine.
        try:
            qmp = QMPClient(self._qmp_shutdown_port)
            qmp.shutdown_vm()
        except Exception as e:
            print("==> failed to gracefully shutdown the VM:", e)
            self.kill()
            return

        print("==> sent shutdown signal to the VM")

        Timer("graceful-shutdown-timeout", self.kill, GRACEFUL_SHUTDOWN_TIMEOUT).start()

    def kill(self):
        if self._process is None:
            raise RuntimeError("can't kill a stopped VM")

        self._process.kill()
        self._process = None

        print("==> killed the virtual machine")

    def cleanup(self):
        shutil.rmtree(str(self._path))


# We only want the instance configuration to be available at startup, and not
# when the build is running. To achieve that, this thread monitors QMP for
# DEVICE_TRY_MOVED events, and when the CD-ROM is ejected it detaches it from
# the virtual machine.
class TrayEjectorThread(threading.Thread):
    def __init__(self, qmp_port):
        super().__init__(name="tray-ejector", daemon=True)
        self._qmp_port = qmp_port

    def run(self):
        # Wait for the QMP port to come online.
        qmp = None
        while True:
            try:
                qmp = QMPClient(self._qmp_port)
                break
            except ConnectionRefusedError:
                time.sleep(0.01)

        try:
            while True:
                data = qmp.wait_for_event("DEVICE_TRAY_MOVED")
                if not data["tray-open"]:
                    continue
                qmp.eject(data["device"])
                print("==> ejected CD-ROM (device: %s)" % data["device"])
        except EOFError:
            # The connection will be closed when the VM shuts down. We don't
            # care if it happens.
            pass


# Simple thread that executes a function after a timeout
class Timer(threading.Thread):
    def __init__(self, name, callback, timeout):
        super().__init__(name=name, daemon=True)

        self._callback = callback
        self._timeout = timeout

    def run(self):
        # The sleep is done in a loop to handle spurious wakeups
        started_at = time.time()
        while time.time() < started_at + self._timeout:
            time.sleep(self._timeout - (time.time() - started_at))

        self._callback()


# QMP (QEMU Machine Protocol) is a way to control VMs spawned with QEMU, and
# to receive events from them. An introduction to the protocol is available at:
#
#    https://wiki.qemu.org/Documentation/QMP
#
# A full list of commands and events is available at:
#
#    https://www.qemu.org/docs/master/qemu-qmp-ref.html#Commands-and-Events-Index
#
class QMPClient:
    def __init__(self, port):
        self._conn = telnetlib.Telnet("127.0.0.1", port)

        # When starting the connection, QEMU sends a greeting message
        # containing the `QMP` key. To finish the handshake, the command
        # `qmp_capabilities` then needs to be sent.
        greeting = self._read_message()
        if "QMP" not in greeting:
            raise RuntimeError("didn't receive a greeting from the QMP server")
        self._write_message({"execute": "qmp_capabilities"})
        self._read_success()

    def shutdown_vm(self):
        self._write_message({"execute": "system_powerdown"})
        self._read_success()

    def eject(self, device, *, force=False):
        self._write_message({
            "execute": "eject",
            "arguments": {
                "device": device,
                "force": force,
            },
        })
        self._read_success()

    def wait_for_event(self, event):
        while True:
            message = self._read_message()
            if "event" in message and message["event"] == event:
                return message["data"]

    def _read_success(self):
        result = self._read_message()
        if "return" not in result:
            raise RuntimeError("QMP returned an error: " + repr(result))

    def _write_message(self, message):
        self._conn.write(json.dumps(message).encode("utf-8") + b"\r\n")

    def _read_message(self):
        return json.loads(self._conn.read_until(b'\n').decode("utf-8").strip())


def run(instance_name):
    with open("instances.json") as f:
        instances = json.load(f)

    instance = None
    for candidate in instances:
        if candidate["name"] == instance_name:
            instance = candidate
            break
    else:
        print(f"error: instance not found: {instance_name}", file=sys.stderr)
        exit(1)

    env = {
        "name": instance["name"],
        "config": instance["config"],
    }

    vm = VM(instance, env)
    vm.run()
    vm.cleanup()


if __name__ == "__main__":
    if len(sys.argv) == 2:
        run(sys.argv[1])
    else:
        print(f"usage: {sys.argv[0]} <instance-name>", file=sys.stderr)
        exit(1)
